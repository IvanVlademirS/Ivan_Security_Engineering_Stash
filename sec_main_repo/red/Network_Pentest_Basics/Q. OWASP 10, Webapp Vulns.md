# OWASP top 10 and OWASP testing checklist
**Open Web Application Security Project**
Top 10 - https://owasp.org/www-project-top-ten/
Cheat Sheets - https://cheatsheetseries.owasp.org/IndexTopTen.html
❗️ Excel checklist for engagements - https://github.com/tanprathan/OWASP-Testing-Checklist
- Testing Guide (used with excel) - https://owasp.org/www-project-web-security-testing-guide/assets/archive/OWASP_Testing_Guide_v4.pdf

# Installing OWASP Juice Shop
Install Juisce Shop Docker in kali: https://medium.com/@airman604/installing-docker-in-kali-linux-2017-1-fbaa4d1447fe
Juice Shop GitHub: https://github.com/bkimminich/juice-shop
Juice Shop Gitbook: https://pwning.owasp-juice.shop/

# Exploring Burp Suite
*can use ZAP for opensource equivalent*
*Make sure foxyproxy is set up*
In webapp testing, typically have three stages of testing:
1. unauthenticated
2. user tier (authenticated)
3. admin tier (admin privileges)
- click around >> get a feel of what's going on >> figure out who has access to what and why
- add `target` to scope in Burp Suite
	- Filter >> `show only in scope items` >> ensure proxy only stores what we need
- Pro Edition >> can use Scan feature
- Intercept >> capture requests
- Repeater >> modify, send requests
- Intercept on > send request to repeater >> forward to see whats happening >> can modify request to test
	- proxy >> options >> turn on (intercept client requests)(intercept server responses) `is in target scope` 
- Intruder >> payloads (slow in free version)
- Extender >> appstore (can install turbo intruder to make intruder faster in free version)
- Decoder >> encode, decode

## Scorboard
>>> localhost:3000/#/score-board
- make sure to use `/#/score-board` as path

# SQL Injection Attacks
What is SQL Injection:
- SQL injection is an attack in which malicious SQL statements are injected into a SQL database
- SQL injection is easy to avoid, but still happens often
- if successful, we can read sensitive databases, extract information, modify databases, and potentially even get a shell

❗️ Common SQL Verbs
- SQL statements begin with verbs:
`SELECT` - retrieves data from a table
`INSERT` - adds data to a table
`DELETE` - removes data from a table
`UPDATE` - modifies data in a table
`DROP` - delete a table
`UNION` - combines data from  multiple queries
extra terms to know:
`FROM` - from
`WHERE` - filters records based on specific condition
`AND/OR/NOT` - filter records based on multiple conditions
`ORDER BY` - sorts records in ascending/descending order

❗️ Special characters
- `'` and `"` - string delimiters
- `--` , `/*`, and `#` - comment delimiters
- `*` and `%` - wildcards
- `;` - ends SQL statement
- others that follow programmatic logic: `- = + > < ()`

## SQL Injection Walkthrough
navigate to account login page
- intercept on >> test // test >> send to repeater
	- in background, SQL is probably looking up `SELECT * FROM Users WHERE email='test';`
	- Open text editor to track input tests: can test for SQLi by adding another `'` >> `...email='test''`
```SQL
-- original - input: test
SELECT * FROM Users WHERE email='test';

-- input: test'
SELECT * FROM Users WHERE email='test'';
```
```SQL
-- input: test' OR 1=1; --  
SELECT * FROM Users WHERE email='test' OR 1=1; --;
```

test and verify in repeater >> check for any "xxxxx_ERROR" >> indicates sqli vulnerability
- typically ID #1 is the admin, so our third input will log us in as admin if sqli vulnerability is present
^ Classic SQLi

Blind Sequel Injection >> use sleep patterns

## SQL Injection Defenses
- Defense 1: Parameterized Statements/Queries (MAIN)
	- ensure inputs (parameters) are used safely in SQL statements
```SQL
--example 1: GOOD, input is separate from parameterized string
SELECT * FROM users WHERE email =?";
```
```SQL
--example 2: BAD, input is part of string
SELECT * FROM users WHERE email ="' +email+"'";
```
- Defense 2: Sanitizing Input

# Broken Authentication Overview and Defenses
OWASP A2-Broken Authentication: [https://www.owasp.org/index.php/Top_10-2017_A2-Broken_Authentication](https://www.owasp.org/index.php/Top_10-2017_A2-Broken_Authentication)

## Testing for Broken Authentication
- Can we bypass authentication?
- in login page >> observe invalid statement for potential info
- Be on the lookout for username enumeration possibilities
- MFA?
- Check SQLi

# Sensitive Data Exposure
OWASP A3-Sensetive Data Exposure: [https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure)

## Testing for Sensitive Data Exposure
- subdomain cracking login page >> we found /ftp
	- files are visible
- look at security headers >> can use securityheaders.com 
	- can verify HSTS and other defenses active or not
- can use nmap to scan for TLS/SSL information (ssl ciphers):
	- A (best) - F (BAD)
```bash
nmap --script=ssl-enum-ciphers -p 443 tesla.com
```

# XML External Entities (XXE) Overview
OWASP A4-XML External Entities: [https://www.owasp.org/index.php/Top_10-2017_A4-XML_External_Entities_(XXE)](https://www.owasp.org/index.php/Top_10-2017_A4-XML_External_Entities_(XXE))

XXE attacks systems that parse XML input
- abuse SYSTEM utilize and get malicious
- attacks include denial of service, local file disclosure, and more
```XML
<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- DTD - doc type definition, entity -->
<!DOCTYPE gift [ 
	<!ENTITY from "Heath&Amber">
]>

<gift> <!-- root -->
	<To>Frank</To> <!-- children -->
	<From>&from;</From> <!-- calling entity -->
	<Item>Pokemon Cards</Item>
</gift>
```
XXE payloads: https://gitlab.com/pentest-tools/PayloadsAllTheThings/-/tree/master/XXE%20Injection
Classic XXE:
```XML
<?xml version="1.0" encoding="ISO-8859-1"?>
  <!DOCTYPE foo [  
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>
```
- uses SYSTEM

## XXE Attack and Defense
When given account >> always check what you have access to and what you can do
- can use Burpsuite pro version to SCAN
In complaint section, there is an upload feature
- can upload XML file >> intercept and send to repeater
	- if XXE vulnerable, you would see printout of the XXE file
	- this means the DTD's are being allowed >> need to DISABLE

# Broken Access Control
OWASP A5-Broken Access Control: [https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control](https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control)

User gets access to somewhere they shouldn't

## Broken Access Control Walkthrough
- customer feedback >> inspect element, find any `hidden`
	- found 18 >> can now try numeric value to bypass user auth

# Security Misconfiguration Attacks and Defenses
OWASP A6-Security Misconfigurations: [https://www.owasp.org/index.php/Top_10-2017_A6-Security_Misconfiguration](https://www.owasp.org/index.php/Top_10-2017_A6-Security_Misconfiguration)

e.g. Default Credentials
❗️ Always check for this on any application you find!

# Cross-Site Scripting
OWASP A7-Cross Site Scripting: [https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS)](https://www.owasp.org/index.php/Top_10-2017_A7-Cross-Site_Scripting_(XSS))

Know the 3 types:
1. Reflected XSS - inject something malicious >> get pop-up reflected back on the page (client side)
2. Stored XSS - persistent >> inject payload and stored on the server (server side)
3. DOM XSS - (js) modifying the document object model (client side)
- Ref and DOM require social engineering
- stored just needs a malicious js

More info on DOM XSS: DOM Based XSS: [https://www.scip.ch/en/?labs.20171214](https://www.scip.ch/en/?labs.20171214)

XSS Game: [https://xss-game.appspot.com/](https://xss-game.appspot.com/)

## Reflected XSS walkthrough
- inspect everything that has an input parameter
Reflected cross-site scripting (or XSS) arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way.

Suppose a website has a search function which receives the user-supplied search term in a URL parameter:

`https://insecure-website.com/search?term=gift`

The application echoes the supplied search term in the response to this URL:

`<p>You searched for: gift</p>`

Assuming the application doesn't perform any other processing of the data, an attacker can construct an attack like this:

`https://insecure-website.com/search?term=<script>/*+Bad+stuff+here...+*/</script>`

This URL results in the following response:

`<p>You searched for: <script>/* Bad stuff here... */</script></p>`

If another user of the application requests the attacker's URL, then the script supplied by the attacker will execute in the victim user's browser, in the context of their session with the application.

## Stored XSS walkthrough
Stored cross-site scripting (also known as second-order or persistent XSS) arises when an application receives data from an untrusted source and includes that data within its later HTTP responses in an unsafe way.

Suppose a website allows users to submit comments on blog posts, which are displayed to other users. Users submit comments using an HTTP request like the following:

`POST /post/comment HTTP/1.1 Host: vulnerable-website.com Content-Length: 100 postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net`

After this comment has been submitted, any user who visits the blog post will receive the following within the application's response:

`<p>This post was extremely helpful.</p>`

Assuming the application doesn't perform any other processing of the data, an attacker can submit a malicious comment like this:

`<script>/* Bad stuff here... */</script>`

Within the attacker's request, this comment would be URL-encoded as:

`comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...%2B*%2F%3C%2Fscript%3E`

Any user who visits the blog post will now receive the following within the application's response:

`<p><script>/* Bad stuff here... */</script></p>`

The script supplied by the attacker will then execute in the victim user's browser, in the context of their session with the application.

## Preventing XSS
- encoding - converting control character to it's escape sequence 
	- `<` becomes `&lt;`
	- `<script>` become `&lt;script>`
- filtering - characters get wiped out
	- `<script>` becomes `script`
- validating - comparing input against whitelist or known good numbers
- sanitization - combination of escaping, filtering, and validation

# Insecure Deserialization
OWASP A8-Insecure Deserialization: [https://www.owasp.org/index.php/Top_10-2017_A8-Insecure_Deserialization](https://www.owasp.org/index.php/Top_10-2017_A8-Insecure_Deserialization)

- serialization - taking data and convert object into format that can be put on a disk, to be sent through a network
- deserialization - opposite >> can serialize exploit, app will take data and serialize it

popular tool = **ysoserial**

# Using components with known vulnerabilities
OWASP A9-Using Components with Known Vulnerabilities: [https://www.owasp.org/index.php/Top_10-2017_A9-Using_Components_with_Known_Vulnerabilities](https://www.owasp.org/index.php/Top_10-2017_A9-Using_Components_with_Known_Vulnerabilities)

- in burpsuite pro >> can go to extender and get additional scanner checks that will detect this
- can run nessus against webapp 
- prevent with PATCHING >> keep apps up-to-date

# Insufficient logging and monitoring
OWASP A10-Insufficient Logging & Monitoring: [https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A10-Insufficient_Logging%252526Monitoring.html](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A10-Insufficient_Logging%252526Monitoring.html)
- must have auditable events and monitoring with alerting
